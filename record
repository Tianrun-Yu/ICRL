<<<<<<< HEAD
# ICRL
=======
baseline: 直接使用basemodel
ICRL: 现在有问题Q，输入：{Q} 进行k次完整推理(A11，A12，...A1k)，然后抓取出数字答案(a11,a12,...a1k), 对数字答案(a11,a12,...a1k)进行投票选出票数最多的答案a1. 然后在1-k随机选择一个回答（A1i，a1i）如果a1i == a1，A1i 对应reward=1，如果a1i ！= a1，A1i 对应reward=0。 然后修改提示词输入：{Q，A1i A1i_reward},进行k次完整推理(A21，A22，...A2k)，然后抓取出数字答案(a21,a22,...a2k)进行投票选出票数最多的答案a1.然后在1-k随机选择一个回答（A2i，a2i）如果a2i == a2，A2i 对应reward=1，如果a2i ！= a2，A2i 对应reward=0。然后修改提示词输入：{Q，A1i A1i_reward， A2i A2i_reward}
以此类推进行n轮，得到{Q，A1i A1i_reward， A2i A2i_reward，，，， Ani Ani_reward}
然后使用这个{Q，A1i A1i_reward， A2i A2i_reward，，，， Ani Ani_reward}来进行评估。 

ICRL0: 现在的随机选择一个浪费了很多信息。假设我的里面最多存5个A1i A1i_reward。前5轮，如何选择Ani 会把对于1-k 都算一下{Q，A1i A1i_reward， A2i A2i_reward，，，， Ani Ani_reward}最后预测数字答案的熵，然后选择一个熵减少最多的k。队友5轮后先选择k里面好的加入进来。然后再从这里面n+1 （6）踢出一个熵减少最少的



运行脚本
conda activate ICRL
bash /home/jovyan/ICRL/scripts/run_icrl.sh Qwen2.5-Math-7B AIME-TTT


